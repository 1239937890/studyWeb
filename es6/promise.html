<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>promise</title>
</head>

<body>
    <script>
        //then()方法成功
        //catch()方法失败
        //finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。
        //all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例
        // p的状态由p1、 p2、 p3决定， 分成两种情况。
        // （ 1） 只有p1、 p2、 p3的状态都变成fulfilled， p的状态才会变成fulfilled， 此时p1、 p2、 p3的返回值组成一个数组， 传递给p的回调函数。
        // （ 2） 只要p1、 p2、 p3之中有一个被rejected， p的状态就变成rejected， 此时第一个被reject的实例的返回值， 会传递给p的回调函数。

        const PENDING = 'pending'
        const FULFILLED = 'fulfilled'
        const REJECTED = 'rejected'
        class MyPromise{
            //构造方法接收一个回调
            constructor(executor){
                this._state = PENDING
                this._resolveQueue = [] //then收集的执行成功的回调队列
                this._rejectQueue = [] //then收集的执行失败的回调队列
                //由于resolve/reject是在executor内部被调用,因此需要使用箭头函数固定this指向,否则找不到this._resolveQueue
                let _resolve = (val)=>{
                    if(this._state != PENDING)return
                    this._state = FULFILLED
                    //从成功队列里取出回调依次执行
                    while(this._resolveQueue.length){
                        const callback = this._resolveQueue.shift()
                        callback(val)
                    }
                }

                let _reject = (val)=>{
                    if(this._state != PENDING )return
                    this._state = REJECTED
                    while(this._rejectQueue.length){
                        const callback =  this._rejectQueue.shift()
                        callback(val)
                    }
                }
                // new Promise()时立即执行executor,并传入resolve和reject
                executor(_resolve,_reject)
            }
            //then方法接收一个成功的回调和一个失败的回调，并push进对应队列
            then(resolveFn,rejectFn){
                //return一个新的promise
                const p2 = new MyPromise((resolve,reject)=>{
                    //把resolveFn重新包装一下，再push进resolve执行队列，这是为了能够获取回调的返回值进行分类讨论
                    const fulfilledFn = value =>{
                        try{
                            //执行第一个(当前的)Promise的成功回调，并获取返回值
                            const x = resolveFn(value)
                            //分类讨论返回值，如果是promise，那么等待Promise状态变更，否则直接resolve
                            //这里resolve之后，就能被下一个.then的回调获取到返回值，从而实现链式调用
                            x instanceof MyPromise?x.then(resolve,reject):resolve(x)
                        }catch(error){
                            reject(error)
                        }
                    }
                    this._resolveQueue.push(fulfilledFn)
                    //reject 同理
                    const rejectedFn = value=>{
                        try{
                            const x = rejectFn(value)
                            x instanceof MyPromise ? x.then(resolve,reject):resolve(x)
                        }catch(error){
                            reject(error)
                        }
                    }
                    this._rejectQueue.push(rejectedFn)
                })
                return p2
            }
        }
        const p1 = new MyPromise((resolve,reject)=>{
            setTimeout(()=>{
                resolve(1)
            },1000)
        })
        p1.then(res=>{
            console.log('res',res)
            return 2
        }).then(res=>{
            console.log(res)
            return 3
        }).then(res=>{
            console.log(res)
        }).then(res=>{
            console.log('res4',res)
        })
    </script>
</body>

</html>