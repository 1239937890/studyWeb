<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>promise</title>
</head>

<body>
    <script>
        //then()方法成功
        //catch()方法失败
        //finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。
        //all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例
        // p的状态由p1、 p2、 p3决定， 分成两种情况。
        // （ 1） 只有p1、 p2、 p3的状态都变成fulfilled， p的状态才会变成fulfilled， 此时p1、 p2、 p3的返回值组成一个数组， 传递给p的回调函数。
        // （ 2） 只要p1、 p2、 p3之中有一个被rejected， p的状态就变成rejected， 此时第一个被reject的实例的返回值， 会传递给p的回调函数。

        class MyPromise{
            //构造方法接收一个回调
            constructor(executor){
                console.log('executor',executor)
                this._resolveQueue = [] //then收集的执行成功的回调队列
                this._rejectQueue = [] //then收集的执行失败的回调队列
                //由于resolve/reject是在executor内部被调用,因此需要使用箭头函数固定this指向,否则找不到this._resolveQueue
                let _resolve = (val)=>{
                    //从成功队列里取出回调依次执行
                    console.log('this._resolveQueue2',this._resolveQueue)
                    while(this._resolveQueue.length){
                        const callback = this._resolveQueue.shift()
                        console.log('callback',callback)
                        callback(val)
                    }
                }

                let _reject = (val)=>{
                    while(this._rejectQueue.length){
                        const callback =  this._rejectQueue.shift()
                        callback(val)
                    }
                }
                // new Promise()时立即执行executor,并传入resolve和reject
                console.log('this._resolveQueue1',this._resolveQueue)
                executor(_resolve,_reject)
            }
            //then方法接收一个成功的回调和一个失败的回调，并push进对应队列
            then(resolveFn,rejectFn){
                console.log('resolveFn',resolveFn)
                this._resolveQueue.push(resolveFn)
                this._rejectQueue.push(rejectFn)
            }
        }
        const p1 = new MyPromise((resolve,reject)=>{
            setTimeout(()=>{
                resolve('结果')
            },1000)
        })
        console.log('p1',p1)
        p1.then(res=>{
            console.log('res',res)
        })
    </script>
</body>

</html>